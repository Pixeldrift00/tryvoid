import { create } from 'zustand';
import { v4 as uuidv4 } from 'uuid';
import { Message, Branch, Suggestion, ConversationNode } from '@/types';
import { useLLMConfig } from './llmConfig';
import { formatChatPrompt, formatSuggestionsPrompt } from '@/lib/prompts';

interface ChatState {
  branches: Branch[];
  activeBranchId: string;
  suggestions: Suggestion[];
  isRadialViewOpen: boolean;
  rootNode: ConversationNode | null;
  
  // Actions
  sendMessage: (content: string) => Promise<void>;
  selectBranch: (branchId: string) => void;
  generateSuggestions: (parentMessageId: string) => Promise<void>;
  selectSuggestion: (suggestion: Suggestion) => void;
  toggleRadialView: () => void;
  buildConversationTree: () => void;
}

// Helper function to create a mock delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// Initial branch
const initialBranchId = uuidv4();
const welcomeMessageId = uuidv4();

const initialWelcomeMessage: Message = {
  id: welcomeMessageId,
  content: "Welcome to Void. What would you like to explore today?",
  sender: 'ai',
  timestamp: new Date(),
  branchId: initialBranchId,
  parentMessageId: null
};

const initialBranch: Branch = {
  id: initialBranchId,
  messages: [initialWelcomeMessage],
  parentBranchId: null,
  parentMessageId: null,
  createdAt: new Date(),
  updatedAt: new Date()
};

// Mock suggestions that would be generated by an AI
const mockSuggestions = [
  "Tell me about consciousness",
  "How does quantum computing work?",
  "Explain the concept of emergence",
  "What is the philosophy of mind?",
  "How do black holes evaporate?",
  "Discuss the ethics of artificial intelligence",
  "What is the relationship between mathematics and reality?",
  "How do complex systems self-organize?",
];

export const useChatStore = create<ChatState>((set, get) => ({
  branches: [initialBranch],
  activeBranchId: initialBranchId,
  suggestions: mockSuggestions.map(content => ({
    id: uuidv4(),
    content,
    branchId: null,
    parentMessageId: welcomeMessageId
  })),
  isRadialViewOpen: false,
  rootNode: null,
  
  sendMessage: async (content: string) => {
    const { branches, activeBranchId } = get();
    const activeBranch = branches.find(b => b.id === activeBranchId);
    
    if (!activeBranch) return;
    
    const newMessageId = uuidv4();
    const userMessage: Message = {
      id: newMessageId,
      content,
      sender: 'user',
      timestamp: new Date(),
      branchId: activeBranchId,
      parentMessageId: activeBranch.messages[activeBranch.messages.length - 1].id
    };
    
    // Add user message
    set(state => ({
      branches: state.branches.map(branch => 
        branch.id === activeBranchId 
          ? { ...branch, messages: [...branch.messages, userMessage], updatedAt: new Date() }
          : branch
      )
    }));

    try {
      const llmService = useLLMConfig.getState().getLLMService();
      
      // Format conversation history
      const messages = activeBranch.messages.map(msg => ({
        role: msg.sender === 'user' ? 'user' : 'assistant',
        content: msg.content,
      }));

      // Get AI response
      const response = await llmService.complete(messages, {
        streaming: {
          enabled: true,
          onToken: (token) => {
            // Update UI with streaming tokens
            set(state => ({
              branches: state.branches.map(branch =>
                branch.id === activeBranchId
                  ? {
                      ...branch,
                      messages: branch.messages.map(msg =>
                        msg.id === aiMessage.id
                          ? { ...msg, content: msg.content + token }
                          : msg
                      ),
                    }
                  : branch
              ),
            }));
          },
        },
      });

      const aiMessage: Message = {
        id: uuidv4(),
        content: response.content,
        sender: 'ai',
        timestamp: new Date(),
        branchId: activeBranchId,
        parentMessageId: newMessageId,
      };

      // Add AI message
      set(state => ({
        branches: state.branches.map(branch =>
          branch.id === activeBranchId
            ? { ...branch, messages: [...branch.messages, aiMessage], updatedAt: new Date() }
            : branch
        ),
      }));

      // Generate new suggestions
      await get().generateSuggestions(aiMessage.id);
    } catch (error) {
      console.error('Failed to get AI response:', error);
      // Handle error appropriately
    }
  },
  
  selectBranch: (branchId) => {
    set({ activeBranchId: branchId });
  },
  
  generateSuggestions: async (parentMessageId: string) => {
    try {
      const llmService = useLLMConfig.getState().getLLMService();
      const { branches } = get();
      
      // Find the message and its context
      const parentMessage = branches
        .flatMap(b => b.messages)
        .find(m => m.id === parentMessageId);
      
      if (!parentMessage) return;

      const response = await llmService.complete([
        {
          role: 'system',
          content: formatSuggestionsPrompt(parentMessage.content),
        },
      ]);

      // Parse suggestions from response
      const suggestions = response.content
        .split('\n')
        .filter(Boolean)
        .map(content => ({
          id: uuidv4(),
          content: content.trim(),
          parentMessageId,
          branchId: null,
        }));

      set({ suggestions });
    } catch (error) {
      console.error('Failed to generate suggestions:', error);
      // Handle error appropriately
    }
  },
  
  selectSuggestion: async (suggestion) => {
    const { branches, activeBranchId } = get();
    const activeBranch = branches.find(b => b.id === activeBranchId);
    
    if (!activeBranch) return;
    
    // If suggestion already has a branch, just switch to it
    if (suggestion.branchId) {
      set({ activeBranchId: suggestion.branchId });
      return;
    }
    
    // Otherwise, create a new branch
    const newBranchId = uuidv4();
    const parentMessage = activeBranch.messages.find(m => m.id === suggestion.parentMessageId);
    
    if (!parentMessage) return;
    
    // Find index of the parent message
    const parentIndex = activeBranch.messages.findIndex(m => m.id === suggestion.parentMessageId);
    if (parentIndex === -1) return;
    
    // Create messages up to the parent message
    const messagesUpToParent = activeBranch.messages.slice(0, parentIndex + 1);
    
    // Create user message from suggestion
    const userMessageId = uuidv4();
    const userMessage: Message = {
      id: userMessageId,
      content: suggestion.content,
      sender: 'user',
      timestamp: new Date(),
      branchId: newBranchId,
      parentMessageId: parentMessage.id
    };
    
    // Create new branch with the messages
    const newBranch: Branch = {
      id: newBranchId,
      messages: [...messagesUpToParent, userMessage],
      parentBranchId: activeBranchId,
      parentMessageId: parentMessage.id,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    // Add the branch and update the suggestion
    set(state => ({
      branches: [...state.branches, newBranch],
      activeBranchId: newBranchId,
      suggestions: state.suggestions.map(s => 
        s.id === suggestion.id 
          ? { ...s, branchId: newBranchId }
          : s
      )
    }));
    
    // Simulate AI thinking
    await delay(1500);
    
    // Generate AI response
    const aiResponseId = uuidv4();
    const aiResponse: Message = {
      id: aiResponseId,
      content: `Based on your interest in "${suggestion.content}", here's an in-depth exploration that opens up new pathways for discussion.`,
      sender: 'ai',
      timestamp: new Date(),
      branchId: newBranchId,
      parentMessageId: userMessageId
    };
    
    // Add AI response to new branch
    set(state => ({
      branches: state.branches.map(branch => 
        branch.id === newBranchId 
          ? { ...branch, messages: [...branch.messages, aiResponse], updatedAt: new Date() }
          : branch
      )
    }));
    
    // Generate new suggestions
    get().generateSuggestions(aiResponseId);
  },
  
  toggleRadialView: () => {
    const { isRadialViewOpen } = get();
    set({ isRadialViewOpen: !isRadialViewOpen });
    
    // Build the conversation tree if opening the view
    if (!isRadialViewOpen) {
      get().buildConversationTree();
    }
  },
  
  buildConversationTree: () => {
    const { branches } = get();
    
    // Create a map of all messages
    const messagesMap = new Map();
    branches.forEach(branch => {
      branch.messages.forEach(message => {
        messagesMap.set(message.id, {
          id: message.id,
          messageId: message.id,
          content: message.content,
          sender: message.sender,
          parentId: message.parentMessageId,
          branchId: message.branchId,
          children: []
        });
      });
    });
    
    // Build the tree
    let rootNode: ConversationNode | null = null;
    
    messagesMap.forEach(node => {
      if (node.parentId === null) {
        rootNode = node;
      } else {
        const parentNode = messagesMap.get(node.parentId);
        if (parentNode) {
          parentNode.children.push(node);
        }
      }
    });
    
    set({ rootNode });
  }
}));
