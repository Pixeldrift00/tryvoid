import { create } from 'zustand';
import { v4 as uuidv4 } from 'uuid';
import { Message, Branch, Suggestion, ConversationNode } from '@/types';

interface ChatState {
  branches: Branch[];
  activeBranchId: string;
  suggestions: Suggestion[];
  isRadialViewOpen: boolean;
  rootNode: ConversationNode | null;
  
  // Actions
  sendMessage: (content: string) => void;
  selectBranch: (branchId: string) => void;
  generateSuggestions: (parentMessageId: string) => void;
  selectSuggestion: (suggestion: Suggestion) => void;
  toggleRadialView: () => void;
  buildConversationTree: () => void;
}

// Helper function to create a mock delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// Initial branch
const initialBranchId = uuidv4();
const welcomeMessageId = uuidv4();

const initialWelcomeMessage: Message = {
  id: welcomeMessageId,
  content: "Welcome to Void. What would you like to explore today?",
  sender: 'ai',
  timestamp: new Date(),
  branchId: initialBranchId,
  parentMessageId: null
};

const initialBranch: Branch = {
  id: initialBranchId,
  messages: [initialWelcomeMessage],
  parentBranchId: null,
  parentMessageId: null,
  createdAt: new Date(),
  updatedAt: new Date()
};

// Mock suggestions that would be generated by an AI
const mockSuggestions = [
  "Tell me about consciousness",
  "How does quantum computing work?",
  "Explain the concept of emergence",
  "What is the philosophy of mind?",
  "How do black holes evaporate?",
  "Discuss the ethics of artificial intelligence",
  "What is the relationship between mathematics and reality?",
  "How do complex systems self-organize?",
];

export const useChatStore = create<ChatState>((set, get) => ({
  branches: [initialBranch],
  activeBranchId: initialBranchId,
  suggestions: mockSuggestions.map(content => ({
    id: uuidv4(),
    content,
    branchId: null,
    parentMessageId: welcomeMessageId
  })),
  isRadialViewOpen: false,
  rootNode: null,
  
  sendMessage: async (content) => {
    const { branches, activeBranchId } = get();
    const activeBranch = branches.find(b => b.id === activeBranchId);
    
    if (!activeBranch) return;
    
    const newMessageId = uuidv4();
    const userMessage: Message = {
      id: newMessageId,
      content,
      sender: 'user',
      timestamp: new Date(),
      branchId: activeBranchId,
      parentMessageId: activeBranch.messages[activeBranch.messages.length - 1].id
    };
    
    // Add user message to active branch
    set(state => ({
      branches: state.branches.map(branch => 
        branch.id === activeBranchId 
          ? { ...branch, messages: [...branch.messages, userMessage], updatedAt: new Date() }
          : branch
      )
    }));
    
    // Simulate AI thinking
    await delay(1500);
    
    // Generate AI response
    const aiResponseId = uuidv4();
    const aiResponse: Message = {
      id: aiResponseId,
      content: `I've processed your request about "${content}". Here's a thoughtful response that demonstrates the power of infinite branching conversations.`,
      sender: 'ai',
      timestamp: new Date(),
      branchId: activeBranchId,
      parentMessageId: newMessageId
    };
    
    // Add AI response to active branch
    set(state => ({
      branches: state.branches.map(branch => 
        branch.id === activeBranchId 
          ? { ...branch, messages: [...branch.messages, aiResponse], updatedAt: new Date() }
          : branch
      )
    }));
    
    // Generate new suggestions
    get().generateSuggestions(aiResponseId);
  },
  
  selectBranch: (branchId) => {
    set({ activeBranchId: branchId });
  },
  
  generateSuggestions: (parentMessageId) => {
    // In a real app, this would call an AI service
    const newSuggestions = mockSuggestions
      .sort(() => Math.random() - 0.5)
      .slice(0, 6)
      .map(content => ({
        id: uuidv4(),
        content,
        branchId: null,
        parentMessageId
      }));
    
    set({ suggestions: newSuggestions });
  },
  
  selectSuggestion: async (suggestion) => {
    const { branches, activeBranchId } = get();
    const activeBranch = branches.find(b => b.id === activeBranchId);
    
    if (!activeBranch) return;
    
    // If suggestion already has a branch, just switch to it
    if (suggestion.branchId) {
      set({ activeBranchId: suggestion.branchId });
      return;
    }
    
    // Otherwise, create a new branch
    const newBranchId = uuidv4();
    const parentMessage = activeBranch.messages.find(m => m.id === suggestion.parentMessageId);
    
    if (!parentMessage) return;
    
    // Find index of the parent message
    const parentIndex = activeBranch.messages.findIndex(m => m.id === suggestion.parentMessageId);
    if (parentIndex === -1) return;
    
    // Create messages up to the parent message
    const messagesUpToParent = activeBranch.messages.slice(0, parentIndex + 1);
    
    // Create user message from suggestion
    const userMessageId = uuidv4();
    const userMessage: Message = {
      id: userMessageId,
      content: suggestion.content,
      sender: 'user',
      timestamp: new Date(),
      branchId: newBranchId,
      parentMessageId: parentMessage.id
    };
    
    // Create new branch with the messages
    const newBranch: Branch = {
      id: newBranchId,
      messages: [...messagesUpToParent, userMessage],
      parentBranchId: activeBranchId,
      parentMessageId: parentMessage.id,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    // Add the branch and update the suggestion
    set(state => ({
      branches: [...state.branches, newBranch],
      activeBranchId: newBranchId,
      suggestions: state.suggestions.map(s => 
        s.id === suggestion.id 
          ? { ...s, branchId: newBranchId }
          : s
      )
    }));
    
    // Simulate AI thinking
    await delay(1500);
    
    // Generate AI response
    const aiResponseId = uuidv4();
    const aiResponse: Message = {
      id: aiResponseId,
      content: `Based on your interest in "${suggestion.content}", here's an in-depth exploration that opens up new pathways for discussion.`,
      sender: 'ai',
      timestamp: new Date(),
      branchId: newBranchId,
      parentMessageId: userMessageId
    };
    
    // Add AI response to new branch
    set(state => ({
      branches: state.branches.map(branch => 
        branch.id === newBranchId 
          ? { ...branch, messages: [...branch.messages, aiResponse], updatedAt: new Date() }
          : branch
      )
    }));
    
    // Generate new suggestions
    get().generateSuggestions(aiResponseId);
  },
  
  toggleRadialView: () => {
    const { isRadialViewOpen } = get();
    set({ isRadialViewOpen: !isRadialViewOpen });
    
    // Build the conversation tree if opening the view
    if (!isRadialViewOpen) {
      get().buildConversationTree();
    }
  },
  
  buildConversationTree: () => {
    const { branches } = get();
    
    // Create a map of all messages
    const messagesMap = new Map();
    branches.forEach(branch => {
      branch.messages.forEach(message => {
        messagesMap.set(message.id, {
          id: message.id,
          messageId: message.id,
          content: message.content,
          sender: message.sender,
          parentId: message.parentMessageId,
          branchId: message.branchId,
          children: []
        });
      });
    });
    
    // Build the tree
    let rootNode: ConversationNode | null = null;
    
    messagesMap.forEach(node => {
      if (node.parentId === null) {
        rootNode = node;
      } else {
        const parentNode = messagesMap.get(node.parentId);
        if (parentNode) {
          parentNode.children.push(node);
        }
      }
    });
    
    set({ rootNode });
  }
}));
